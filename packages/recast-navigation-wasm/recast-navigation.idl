interface rcConfig {
    void rcConfig();

    attribute long width;
    attribute long height;
    attribute long tileSize;
    attribute long borderSize;
    attribute float cs;
    attribute float ch;
    attribute float[] bmin; 
    attribute float[] bmax;
    attribute float walkableSlopeAngle;
    attribute long walkableHeight;
    attribute long walkableClimb;
    attribute long walkableRadius;
    attribute long maxEdgeLen;
    attribute float maxSimplificationError;
    attribute long minRegionArea;
    attribute long mergeRegionArea;
    attribute long maxVertsPerPoly;
    attribute float detailSampleDist;
    attribute float detailSampleMaxError;
};

interface dtMeshHeader {
    attribute long magic;
    attribute long version;
    attribute long x;
    attribute long y;
    attribute long layer;
    attribute unsigned long userId;
    attribute long polyCount;
    attribute long vertCount;
    attribute long maxLinkCount;
    attribute long detailMeshCount;
    attribute long detailVertCount;
    attribute long detailTriCount;
    attribute long bvNodeCount;
    attribute long offMeshConCount;
    attribute long offMeshBase;
    attribute float walkableHeight;
    attribute float walkableRadius;
    attribute float walkableClimb;
    attribute float[] bmin;
    attribute float[] bmax;
    attribute float bvQuantFactor;
};

interface dtPoly {
    attribute unsigned long firstLink;
    attribute unsigned short[] verts;
    attribute unsigned short[] neis;
    attribute unsigned short flags;
    attribute octet vertCount;
    attribute octet areaAndtype;

    void setArea(octet a);
    void setType(octet a);
    octet getType();
    octet getArea();
};

interface dtPolyDetail {
    attribute long vertBase;
    attribute long triBase;
    attribute octet vertCount;
    attribute octet triCount;
};

interface dtLink {
    attribute unsigned long ref;
    attribute unsigned long next;
    attribute octet edge;
    attribute octet side;
    attribute octet bmin;
    attribute octet bmax;
};

interface dtBVNode {
    attribute unsigned short[] bmin;
    attribute unsigned short[] bmax;
    attribute long i;
};

interface dtOffMeshConnection {
    attribute float[] pos;
    attribute float rad;
    attribute unsigned short poly;
    attribute octet flags;
    attribute octet side;
    attribute unsigned long userId;
};

interface dtMeshTile {
    attribute unsigned long salt;

    attribute long linksFreeList;
    attribute dtMeshHeader header;
    [Value] attribute dtPoly[] polys;
    attribute float[] verts;
    [Value] attribute dtLink[] links;
    [Value] attribute dtPolyDetail[] detailMeshes;
    attribute float[] detailVerts;
    attribute octet[] detailTris;
    [Value] attribute dtBVNode[] bvTree;
    [Value] attribute dtOffMeshConnection[] offMeshCons;
    attribute octet[] data;
    attribute long dataSize;
    attribute long flags;
    attribute dtMeshTile next; 
};

interface dtNavMesh {
};

interface dtNavMeshCreateParams {
    void dtNavMeshCreateParams();

    readonly attribute unsigned short[] verts;
    attribute long vertCount;
    readonly attribute unsigned short[] polys;
    readonly attribute unsigned short[] polyFlags;
    readonly attribute octet[] polyAreas;
    attribute long polyCount;
    attribute long nvp;

    readonly attribute unsigned long[] detailMeshes;
    readonly attribute float[] detailVerts;
    attribute long detailVertsCount;
    readonly attribute octet[] detailTris;
    attribute long detailTriCount;

    readonly attribute float[] offMeshConVerts;
    readonly attribute float[] offMeshConRad;
    readonly attribute unsigned short[] offMeshConFlags;
    readonly attribute octet[] offMeshConAreas;
    readonly attribute octet[] offMeshConDir;
    readonly attribute unsigned long[] offMeshConUserID;
    attribute long offMeshConCount;

    attribute unsigned long userId;
    attribute long tileX;
    attribute long tileY;
    attribute long tileLayer;
    attribute float[] bmin;
    attribute float[] bmax;

    attribute float walkableHeight;
    attribute float walkableRadius;
    attribute float walkableClimb;
    attribute float cs;
    attribute float ch;

    attribute boolean buildBvTree;
};

interface dtObstacleRef {

};

interface dtCompressedTileRef {

};

interface dtNavMeshParams {
    void dtNavMeshParams();

    attribute float[] orig;
    attribute float tileWidth;
    attribute float tileHeight;
    attribute long maxTiles;
    attribute long maxPolys;
};

interface dtCrowdAgentParams {
    void dtCrowdAgentParams();

    /// Agent radius. [Limit: >= 0]
    attribute float radius;                        

    /// Agent slow down radius. [Limit: >= 0]
    attribute float slowDownRadius;                        
    
    /// Agent height. [Limit: > 0]
    attribute float height;                        
    
    /// Maximum allowed acceleration. [Limit: >= 0]
    attribute float maxAcceleration;                
    
    /// Maximum allowed speed. [Limit: >= 0]
    attribute float maxSpeed;                        

    /// Defines how close a collision element must be before it is considered for steering behaviors. [Limits: > 0]
    attribute float collisionQueryRange;

    /// The path visibility optimization range. [Limit: > 0]
    attribute float pathOptimizationRange;        

    /// How aggresive the agent manager should be at avoiding collisions with this agent. [Limit: >= 0]
    attribute float separationWeight;

    /// Flags that impact steering behavior. (See: #UpdateFlags)
    attribute octet updateFlags;

    /// The index of the avoidance configuration to use for the agent. 
    /// [Limits: 0 <= value <= #DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS]
    attribute octet obstacleAvoidanceType;    

    /// The index of the query filter used by this agent.
    attribute octet queryFilterType;

    /// User defined data attached to the agent.
    attribute VoidPtr userData;
};

interface rcSpan {
    attribute long smin;
    attribute long smax;
    attribute long area;
    attribute rcSpan next;
};

interface rcSpanPool {
    attribute rcSpanPool next;
    [Value] attribute rcSpan[] items;
};

interface rcHeightfield {
    attribute long width;
    attribute long height;
    attribute float[] bmin;
    attribute float[] bmax;
    attribute float cs;
    attribute float ch;
    attribute rcSpan[] spans;
    [Value] attribute rcSpanPool[] pools;
    [Value] attribute rcSpan[] freelist;
};

interface rcCompactCell {
    attribute unsigned long index;
    attribute unsigned long count;
};

interface rcCompactSpan {
    attribute unsigned short y;
    attribute unsigned short reg;
    attribute unsigned long con;
    attribute unsigned long h;
};

interface rcCompactHeightfield {
    attribute long width;
    attribute long height;
    attribute long spanCount;
    attribute long walkableHeight;
    attribute long walkableClimb;
    attribute long borderSize;
    attribute unsigned short maxDistance;
    attribute unsigned short maxRegions;
    attribute float[] bmin;
    attribute float[] bmax;
    attribute float cs;
    attribute float ch;
    [Value] attribute rcCompactCell[] cells;
    [Value] attribute rcCompactSpan[] spans;
    attribute unsigned short[] dist;
    attribute octet[] areas;
};

interface rcContour {
    attribute long[] verts;
    attribute long nverts;
    attribute long[] rverts;
    attribute long nrverts;
    attribute unsigned short reg;
    attribute octet area;
};

interface rcContourSet {
    [Value] attribute rcContour[] conts;
    attribute long nconts;
    attribute float[] bmin;
    attribute float[] bmax;
    attribute float cs;
    attribute float ch;
    attribute long width;
    attribute long height;
    attribute long borderSize;
    attribute float maxError;
};

interface rcHeightfieldLayer {
    attribute float[] bmin;
    attribute float[] bmax;
    attribute float cs;
    attribute float ch;
    attribute long width;
    attribute long height;
    attribute long minx;
    attribute long maxx;
    attribute long miny;
    attribute long maxy;
    attribute long hmin;
    attribute long hmax;
    attribute octet[] heights;
    attribute octet[] areas;
    attribute octet[] cons;
};

interface rcHeightfieldLayerSet {
    [Value] attribute rcHeightfieldLayer[] layers;
    attribute long nlayers;
};

interface rcPolyMesh {
    attribute unsigned short[] verts;
    attribute unsigned short[] polys;
    attribute unsigned short[] regs;
    attribute unsigned short[] flags;
    attribute octet[] areas;
    attribute long nverts;
    attribute long npolys;
    attribute long maxpolys;
    attribute long nvp;
    attribute float[] bmin;
    attribute float[] bmax;
    attribute float cs;
    attribute float ch;
    attribute long borderSize;
    attribute float maxEdgeError;
};

interface rcPolyMeshDetail {
    attribute long[] meshes;
    attribute float[] verts;
    attribute octet[] tris;
    attribute long nmeshes;
    attribute long nverts;
    attribute long ntris;
};

interface Vec3 {
    attribute float x;
    attribute float y;
    attribute float z;

    void Vec3();
    void Vec3(float x, float y, float z);
};

interface NavMeshRemoveTileResult {
    attribute unsigned long status;
    attribute octet[] data;
    attribute long dataSize;
};

interface NavMeshCalcTileLocResult {
    attribute long tileX;
    attribute long tileY;
};

interface NavMeshGetTilesAtResult {
    [Value, Const] readonly attribute dtMeshTile[] tiles;
    attribute long tileCount; 
};

interface NavMeshGetTileAndPolyByRefResult {
    attribute unsigned long status;
    [Const] attribute dtMeshTile tile;
    [Const] attribute dtPoly poly;
};

interface NavMeshStoreTileStateResult {
    attribute unsigned long status;
    attribute octet[] data;
    attribute long dataSize;
};

interface NavMesh {
    void NavMesh();
    void NavMesh(dtNavMesh navMesh);

    attribute dtNavMesh m_navMesh;

    boolean initSolo(UnsignedCharArray navMeshData);    
    boolean initTiled([Const] dtNavMeshParams params);
    unsigned long addTile(UnsignedCharArray navMeshData, long flags, unsigned long lastRef, UnsignedIntRef tileRef);
    void decodePolyId(unsigned long polyRef, UnsignedIntRef salt, UnsignedIntRef it, UnsignedIntRef ip);
    unsigned long encodePolyId(unsigned long salt, unsigned long it, unsigned long ip);
    [Value] NavMeshRemoveTileResult removeTile(unsigned long ref);
    dtNavMesh getNavMesh();
    [Value] NavMeshCalcTileLocResult calcTileLoc([Const] float[] pos);
    [Const] dtMeshTile getTileAt([Const] long x, [Const] long y, [Const] long layer);
    [Value] NavMeshGetTilesAtResult getTilesAt([Const] long x, [Const] long y, [Const] long maxTiles);
    unsigned long getTileRefAt(long x, long y, long layer);
    unsigned long getTileRef([Const] dtMeshTile tile);
    [Const] dtMeshTile getTileByRef(unsigned long ref);
    long getMaxTiles();
    [Const] dtMeshTile getTile(long i);
    [Value] NavMeshGetTileAndPolyByRefResult getTileAndPolyByRef([Const] unsigned long ref);
    [Value] NavMeshGetTileAndPolyByRefResult getTileAndPolyByRefUnsafe([Const] unsigned long ref);
    boolean isValidPolyRef(unsigned long ref);
    unsigned long getPolyRefBase([Const] dtMeshTile tile);
    unsigned long getOffMeshConnectionPolyEndPoints(unsigned long prevRef, unsigned long polyRef, Vec3 startPos, Vec3 endPos);
    [Const] dtOffMeshConnection getOffMeshConnectionByRef(unsigned long ref);
    unsigned long setPolyFlags(unsigned long ref, unsigned short flags);
    unsigned long getPolyFlags(unsigned long ref, UnsignedShortRef flags);
    unsigned long setPolyArea(unsigned long ref, octet area);
    unsigned long getPolyArea(unsigned long ref, UnsignedCharRef area);
    unsigned long getTileStateSize([Const] dtMeshTile tile);
    [Value] NavMeshStoreTileStateResult storeTileState([Const] dtMeshTile tile, [Const] long maxDataSize);
    unsigned long restoreTileState(dtMeshTile tile, [Const] octet[] data, [Const] long maxDataSize);
    void destroy();
};

interface FastRand {
    static long getSeed();
    static void setSeed(long seed);
};

interface dtRaycastHit {
    void dtRaycastHit();

    attribute float t;
    attribute float[] hitNormal;
    attribute long hitEdgeIndex;
    attribute unsigned long[] path;
    attribute long pathCount;
    attribute long maxPath;
    attribute float pathCost;
};

enum dtStraightPathFlags {
    "dtStraightPathFlags::DT_STRAIGHTPATH_START",
    "dtStraightPathFlags::DT_STRAIGHTPATH_END",
    "dtStraightPathFlags::DT_STRAIGHTPATH_OFFMESH_CONNECTION"
};

enum dtStraightPathOptions {
    "dtStraightPathOptions::DT_STRAIGHTPATH_AREA_CROSSINGS",
    "dtStraightPathOptions::DT_STRAIGHTPATH_ALL_CROSSINGS",
};

enum dtFindPathOptions {
    "dtFindPathOptions::DT_FINDPATH_ANY_ANGLE"
};

enum dtRaycastOptions {
    "dtRaycastOptions::DT_RAYCAST_USE_COSTS"
};

interface NavMeshQuery {
    attribute dtNavMeshQuery m_navQuery;

    void NavMeshQuery();
    
    void NavMeshQuery(dtNavMeshQuery navMeshQuery);

    unsigned long init(NavMesh navMesh, [Const] long maxNodes);

    unsigned long findPath(unsigned long startRef, unsigned long endRef, [Const] float[] startPos, [Const] float[] endPos, [Const] dtQueryFilter filter, UnsignedIntArray path, long maxPath);

    unsigned long closestPointOnPoly(unsigned long ref, [Const] float[] pos, Vec3 closest, BoolRef posOverPoly);

    unsigned long findClosestPoint([Const] float[] position, [Const] float[] halfExtents, [Const] dtQueryFilter filter, UnsignedIntRef resultPolyRef, Vec3 resultPoint, BoolRef resultPosOverPoly);

    unsigned long findStraightPath([Const] float[] startPos, [Const] float[] endPos, UnsignedIntArray pathPolys, FloatArray straightPath, UnsignedCharArray straightPathFlags, UnsignedIntArray straightPathRefs, IntRef straightPathCountRef, [Const] long maxStraightPath, [Const] long options);

    unsigned long findNearestPoly([Const] float[] center, [Const] float[] halfExtents, [Const] dtQueryFilter filter, UnsignedIntRef nearestRef, Vec3 nearestPt, BoolRef isOverPoly);

    unsigned long findPolysAroundCircle(unsigned long startRef, [Const] float[] centerPos, [Const] float radius, [Const] dtQueryFilter filter, UnsignedIntArray resultRef, UnsignedIntArray resultParent, FloatArray resultCost, IntRef resultCount, [Const] long maxResult);

    unsigned long queryPolygons([Const] float[] center, [Const] float[] halfExtents, [Const] dtQueryFilter filter, UnsignedIntArray polys, IntRef polyCount, [Const] long maxPolys);

    unsigned long raycast(unsigned long startRef, [Const] float[] startPos, [Const] float[] endPos, [Const] dtQueryFilter filter, [Const] unsigned long options, dtRaycastHit hit, unsigned long prevRef);

    unsigned long findRandomPointAroundCircle(unsigned long startRef, [Const] float[] centerPos, float radius, [Const] dtQueryFilter filter, UnsignedIntRef resultRandomRef, Vec3 resultRandomPoint);

    unsigned long moveAlongSurface(unsigned long startRef, float[] startPos, float[] endPos, [Const] dtQueryFilter filter, Vec3 resultPos, UnsignedIntArray visited, long maxVisitedSize);

    unsigned long findRandomPoint([Const] dtQueryFilter filter, UnsignedIntRef resultRandomRef, Vec3 resultRandomPoint);

    unsigned long getPolyHeight(unsigned long ref, float[] pos, FloatRef height);

    void destroy();
};

interface dtTileCacheParams {
    void dtTileCacheParams();

    attribute float[] orig;
    attribute float cs;
    attribute float ch;
    attribute long width;
    attribute long height;
    attribute float walkableHeight;
    attribute float walkableRadius;
    attribute float walkableClimb;
    attribute float maxSimplificationError;
    attribute long maxTiles;
    attribute long maxObstacles;
};

interface TileCacheAddTileResult {
    attribute unsigned long status;
    attribute unsigned long tileRef;
};

interface TileCacheUpdateResult {
    attribute unsigned long status;
    attribute boolean upToDate;
};

interface TileCacheAddObstacleResult {
    attribute unsigned long status;
    attribute dtObstacleRef ref;
};

interface dtTileCacheCompressor {
};

interface RecastFastLZCompressor {
    void RecastFastLZCompressor();
};
RecastFastLZCompressor implements dtTileCacheCompressor;

interface TileCacheMeshProcessJsImpl {
    void process(dtNavMeshCreateParams params, UnsignedCharArray polyAreas, UnsignedShortArray polyFlags);
};

[JSImplementation="TileCacheMeshProcessJsImpl"]
interface TileCacheMeshProcess {
    void TileCacheMeshProcess();

    void process(dtNavMeshCreateParams params, UnsignedCharArray polyAreas, UnsignedShortArray polyFlags);
};

interface dtTileCacheAlloc {
};

interface RecastLinearAllocator {
    void RecastLinearAllocator(unsigned long long cap);
};
RecastLinearAllocator implements dtTileCacheAlloc;

interface TileCache {
    void TileCache();

    boolean init([Const] dtTileCacheParams params, RecastLinearAllocator allocator, RecastFastLZCompressor compressor, [Ref] TileCacheMeshProcess meshProcess);
    [Value] TileCacheAddTileResult addTile(UnsignedCharArray data, octet flags);
    unsigned long buildNavMeshTile([Const] dtCompressedTileRef ref, NavMesh navMesh);
    unsigned long buildNavMeshTilesAt([Const] long tx, [Const] long ty, NavMesh navMesh);
    [Value] TileCacheUpdateResult update(NavMesh navMesh);
    [Value] TileCacheAddObstacleResult addCylinderObstacle([Const, Ref] Vec3 position, float radius, float height);
    [Value] TileCacheAddObstacleResult addBoxObstacle([Const, Ref] Vec3 position, [Const, Ref] Vec3 extent, float angle);
    unsigned long removeObstacle(dtObstacleRef obstacle);
    void destroy();
};

interface CrowdUtils {
    void CrowdUtils();

    long getActiveAgentCount(dtCrowd crowd);
    boolean overOffMeshConnection(dtCrowd crowd, [Const] long idx);
    void agentTeleport(dtCrowd crowd, [Const] long idx, [Const] float[] destination, [Const] float[] halfExtents, dtQueryFilter filter);
};

enum dtTileFlags {
    "dtTileFlags::DT_TILE_FREE_DATA"
};

interface Detour {
    void Detour();

    attribute long FAILURE;
    attribute long SUCCESS;
    attribute long IN_PROGRESS;
    attribute long STATUS_DETAIL_MASK;
    attribute long WRONG_MAGIC;
    attribute long WRONG_VERSION;
    attribute long OUT_OF_MEMORY;
    attribute long INVALID_PARAM;
    attribute long BUFFER_TOO_SMALL;
    attribute long OUT_OF_NODES;
    attribute long PARTIAL_RESULT;
    attribute long ALREADY_OCCUPIED;

    attribute long VERTS_PER_POLYGON;
    attribute long NAVMESH_MAGIC;
    attribute long NAVMESH_VERSION;
    attribute long NAVMESH_STATE_MAGIC;
    attribute long NAVMESH_STATE_VERSION;

    attribute long TILECACHE_MAGIC;
    attribute long TILECACHE_VERSION;
    attribute octet TILECACHE_NULL_AREA;
    attribute octet TILECACHE_WALKABLE_AREA;
    attribute unsigned short TILECACHE_NULL_IDX;

    attribute unsigned long NULL_LINK;
    attribute unsigned short EXT_LINK;
    attribute unsigned long OFFMESH_CON_BIDIR;

    boolean statusSucceed(unsigned long status);
    boolean statusFailed(unsigned long status);
    boolean statusInProgress(unsigned long status);
    boolean statusDetail(unsigned long status, unsigned long detail);

    dtCrowd allocCrowd();
    void freeCrowd(dtCrowd crowd);
};

enum CrowdAgentState {
    "CrowdAgentState::DT_CROWDAGENT_STATE_INVALID",
    "CrowdAgentState::DT_CROWDAGENT_STATE_WALKING",
    "CrowdAgentState::DT_CROWDAGENT_STATE_OFFMESH"
};

enum MoveRequestState {
    "MoveRequestState::DT_CROWDAGENT_TARGET_NONE",
    "MoveRequestState::DT_CROWDAGENT_TARGET_FAILED",
    "MoveRequestState::DT_CROWDAGENT_TARGET_VALID",
    "MoveRequestState::DT_CROWDAGENT_TARGET_REQUESTING",
    "MoveRequestState::DT_CROWDAGENT_TARGET_WAITING_FOR_QUEUE",
    "MoveRequestState::DT_CROWDAGENT_TARGET_WAITING_FOR_PATH",
    "MoveRequestState::DT_CROWDAGENT_TARGET_VELOCITY" 
};

interface dtPathCorridor {
    boolean init([Const] long maxPath);
    void reset(unsigned long ref, [Const] float[] pos);
};

interface dtLocalBoundary {
    void reset();
};

interface dtCrowdNeighbour {
    void dtCrowdNeighbour();

    attribute long idx;
    attribute float dist;
};

interface dtCrowdAgent {
    void dtCrowdAgent();

    attribute boolean active;
    attribute octet state;
    [Value] readonly attribute dtPathCorridor corridor;
    [Value] readonly attribute dtLocalBoundary boundary;
    attribute float topologyOptTime;
    [Value] attribute dtCrowdNeighbour[] neis;
    attribute long nneis;
    attribute float desiredSpeed;
    attribute float[] npos;
    attribute float[] disp;
    attribute float[] dvel;
    attribute float[] nvel;
    attribute float[] vel;
    [Value] attribute dtCrowdAgentParams params;
    attribute float[] cornerVerts;
    attribute octet[] cornerFlags;
    attribute long ncorners;
    attribute octet targetState;
    attribute unsigned long targetRef;
    attribute float[] targetPos;
    attribute unsigned long targetPathqRef;
    attribute boolean targetReplan;
    attribute float targetReplanTime;
};

interface dtObstacleAvoidanceParams {
    void dtObstacleAvoidanceParams();

    attribute float velBias;
	attribute float weightDesVel;
	attribute float weightCurVel;
	attribute float weightSide;
	attribute float weightToi;
	attribute float horizTime;
	attribute octet gridSize;
	attribute octet adaptiveDivs;
	attribute octet adaptiveRings;
	attribute octet adaptiveDepth;
};

interface dtObstacleAvoidanceDebugData {
};

interface dtCrowdAgentDebugInfo {
    void dtCrowdAgentDebugInfo();

    attribute long idx;
    attribute float[] optStart;
    attribute float[] optEnd;
    attribute dtObstacleAvoidanceDebugData vod;
};

interface dtCrowdAgentAnimation {
    
    attribute boolean active;
    attribute float[] initPos;
    attribute float[] startPos;
    attribute float[] endPos;
    attribute unsigned long polyRef;
    attribute float t;
    attribute float tmid;
    attribute float tmax;
    attribute float tScale;
    attribute float[] unitExitVel;

};

interface dtQueryFilter {
    void dtQueryFilter();

    // float getCost([Const] float[] pa, [Const] float[] pb,
	// 			  [Const] unsigned long prevRef, [Const] dtMeshTile prevTile, [Const] dtPoly prevPoly,
	// 			  [Const] unsigned long curRef, [Const] dtMeshTile curTile, [Const] dtPoly curPoly,
	// 			  [Const] unsigned long nextRef, [Const] dtMeshTile nextTile, [Const] dtPoly nextPoly);

    float getAreaCost([Const] long i);

    void setAreaCost([Const] long i, [Const] float cost);

    unsigned short getIncludeFlags();

    void setIncludeFlags([Const] unsigned short flags);

    unsigned short getExcludeFlags();

    void setExcludeFlags([Const] unsigned short flags);
};

interface dtNavMeshQuery {
    [Const] dtNavMesh getAttachedNavMesh();
};

interface dtCrowd {
    void dtCrowd();

    boolean init([Const] long maxAgents, [Const] float maxAgentRadius, dtNavMesh nav);
    
    void setObstacleAvoidanceParams([Const] long idx, [Const] dtObstacleAvoidanceParams params);

    [Const] dtObstacleAvoidanceParams getObstacleAvoidanceParams([Const] long idx);

    [Const] dtCrowdAgent getAgent([Const] long idx);

    dtCrowdAgent getEditableAgent([Const] long idx);

    long getAgentCount();

    long addAgent([Const] float[] pos, [Const] dtCrowdAgentParams params);

    void updateAgentParameters([Const] long idx, [Const] dtCrowdAgentParams params);

    void removeAgent([Const] long idx);

    boolean requestMoveTarget([Const] long idx, unsigned long ref, [Const] float[] pos);

    boolean requestMoveVelocity([Const] long idx, [Const] float[] vel);

    boolean resetMoveTarget([Const] long idx);

    void update([Const] float dt, dtCrowdAgentDebugInfo debug); 

    [Const] dtQueryFilter getFilter([Const] long i);

    dtQueryFilter getEditableFilter([Const] long i);

    [Const] dtNavMeshQuery getNavMeshQuery();

    dtCrowdAgentAnimation getAgentAnimation([Const] long idx);
};

enum rcBuildContoursFlags {
    "rcBuildContoursFlags::RC_CONTOUR_TESS_WALL_EDGES",
    "rcBuildContoursFlags::RC_CONTOUR_TESS_AREA_EDGES"
};

enum rcLogCategory {
	"rcLogCategory::RC_LOG_PROGRESS",
	"rcLogCategory::RC_LOG_WARNING",
    "rcLogCategory::RC_LOG_ERROR"
};

enum rcTimerLabel
{
	"rcTimerLabel::RC_TIMER_TOTAL",
	"rcTimerLabel::RC_TIMER_TEMP",
	"rcTimerLabel::RC_TIMER_RASTERIZE_TRIANGLES",
	"rcTimerLabel::RC_TIMER_BUILD_COMPACTHEIGHTFIELD",
	"rcTimerLabel::RC_TIMER_BUILD_CONTOURS",
	"rcTimerLabel::RC_TIMER_BUILD_CONTOURS_TRACE",
	"rcTimerLabel::RC_TIMER_BUILD_CONTOURS_SIMPLIFY",
	"rcTimerLabel::RC_TIMER_FILTER_BORDER",
	"rcTimerLabel::RC_TIMER_FILTER_WALKABLE",
	"rcTimerLabel::RC_TIMER_MEDIAN_AREA",
	"rcTimerLabel::RC_TIMER_FILTER_LOW_OBSTACLES",
	"rcTimerLabel::RC_TIMER_BUILD_POLYMESH",
	"rcTimerLabel::RC_TIMER_MERGE_POLYMESH",
	"rcTimerLabel::RC_TIMER_ERODE_AREA",
	"rcTimerLabel::RC_TIMER_MARK_BOX_AREA",
	"rcTimerLabel::RC_TIMER_MARK_CYLINDER_AREA",
	"rcTimerLabel::RC_TIMER_MARK_CONVEXPOLY_AREA",
	"rcTimerLabel::RC_TIMER_BUILD_DISTANCEFIELD",
	"rcTimerLabel::RC_TIMER_BUILD_DISTANCEFIELD_DIST",
	"rcTimerLabel::RC_TIMER_BUILD_DISTANCEFIELD_BLUR",
	"rcTimerLabel::RC_TIMER_BUILD_REGIONS",
	"rcTimerLabel::RC_TIMER_BUILD_REGIONS_WATERSHED",
	"rcTimerLabel::RC_TIMER_BUILD_REGIONS_EXPAND",
	"rcTimerLabel::RC_TIMER_BUILD_REGIONS_FLOOD",
	"rcTimerLabel::RC_TIMER_BUILD_REGIONS_FILTER",
	"rcTimerLabel::RC_TIMER_BUILD_LAYERS", 
	"rcTimerLabel::RC_TIMER_BUILD_POLYMESHDETAIL",
	"rcTimerLabel::RC_TIMER_MERGE_POLYMESHDETAIL",
	"rcTimerLabel::RC_MAX_TIMERS"
};

enum dtCompressedTileFlags {
    "dtCompressedTileFlags::DT_COMPRESSEDTILE_FREE_DATA"
};

interface rcContext {
    void rcContext();

    void enableLog(boolean state);
    void resetLog();
    void log([Const] rcLogCategory category, [Const] DOMString message);

    void enableTimer(boolean state);
    void resetTimers();
    void startTimer([Const] rcTimerLabel label);
    void stopTimer([Const] rcTimerLabel label);
    float getAccumulatedTime([Const] rcTimerLabel label);
};

interface RecastBuildContextJsImpl {
    void resetLog();
    void log([Const] rcLogCategory category, [Const] DOMString msg, [Const] long len);
    
    void resetTimers();
    void startTimer([Const] rcTimerLabel label);
    void stopTimer([Const] rcTimerLabel label);
    long getAccumulatedTime([Const] rcTimerLabel label);
};

[JSImplementation="RecastBuildContextJsImpl"]
interface RecastBuildContextImpl {
    void RecastBuildContextImpl();

    void resetLog();
    void log([Const] rcLogCategory category, [Const] DOMString msg, [Const] long len);
    
    void resetTimers();
    void startTimer([Const] rcTimerLabel label);
    void stopTimer([Const] rcTimerLabel label);
    long getAccumulatedTime([Const] rcTimerLabel label);
};

interface RecastBuildContext {
    void RecastBuildContext(RecastBuildContextImpl impl);

    void enableLog(boolean state);
    void resetLog();
    void log([Const] rcLogCategory category, [Const] DOMString message);
    void enableTimer(boolean state);
    void resetTimers();
    void startTimer([Const] rcTimerLabel label);
    void stopTimer([Const] rcTimerLabel label);
    float getAccumulatedTime([Const] rcTimerLabel label);
    boolean logEnabled();
    boolean timerEnabled();
};
RecastBuildContext implements rcContext;

interface RecastCalcBoundsResult {
    attribute float[] bmin;
    attribute float[] bmax;
};

interface RecastCalcGridSizeResult {
    attribute long width;
    attribute long height;
};

interface Recast {
    void Recast();
    
    attribute unsigned short BORDER_REG;
    attribute unsigned short MULTIPLE_REGS;
    attribute long BORDER_VERTEX;
    attribute long AREA_BORDER;
    attribute long CONTOUR_REG_MASK;
    attribute unsigned short MESH_NULL_IDX;
    attribute octet NULL_AREA;
    attribute octet WALKABLE_AREA;
    attribute long NOT_CONNECTED;

    RecastCalcBoundsResult calcBounds([Const] FloatArray verts, long nv);

    RecastCalcGridSizeResult calcGridSize([Const] float[] bmin, [Const] float[] bmax, float cs);

    boolean createHeightfield(rcContext ctx, [Ref] rcHeightfield hf, long width, long height, [Const] float[] bmin, [Const] float[] bmax, float cs, float ch);

    void markWalkableTriangles(rcContext ctx, [Const] float walkableSlopeAngle, [Const] FloatArray verts, long nv, [Const] IntArray tris, long nt, UnsignedCharArray areas);

    void clearUnwalkableTriangles(rcContext ctx, [Const] float walkableSlopeAngle, [Const] FloatArray verts, long nv, [Const] IntArray tris, long nt, UnsignedCharArray areas);

    boolean rasterizeTriangles(rcContext ctx, [Const] FloatArray verts, long nv, [Const] IntArray tris, UnsignedCharArray areas, long nt, [Ref] rcHeightfield solid, long flagMergeThr);

    void filterLowHangingWalkableObstacles(rcContext ctx, long walkableClimb, [Ref] rcHeightfield solid);

    void filterLedgeSpans(rcContext ctx, long walkableHeight, long walkableClimb, [Ref] rcHeightfield solid);

    void filterWalkableLowHeightSpans(rcContext ctx, long walkableHeight, [Ref] rcHeightfield solid);

    long getHeightFieldSpanCount(rcContext ctx, [Ref] rcHeightfield solid);

    boolean buildCompactHeightfield(rcContext ctx, long walkableHeight, long walkableClimb, [Ref] rcHeightfield solid, [Ref] rcCompactHeightfield chf);

    boolean erodeWalkableArea(rcContext ctx, long radius, [Ref] rcCompactHeightfield chf);

    boolean medianFilterWalkableArea(rcContext ctx, [Ref] rcCompactHeightfield chf);

    void markBoxArea(rcContext ctx, [Const] float[] bmin, [Const] float[] bmax, octet areaId, [Ref] rcCompactHeightfield chf);

    void markConvexPolyArea(rcContext ctx, [Const] FloatArray verts, long nverts, [Const] float hmin, [Const] float hmax, octet areaId, [Ref] rcCompactHeightfield chf);

    void markCylinderArea(rcContext ctx, [Const] float[] pos, float r, float h, octet areaId, [Ref] rcCompactHeightfield chf);

    boolean buildDistanceField(rcContext ctx, [Ref] rcCompactHeightfield chf);

    boolean buildRegions(rcContext ctx, [Ref] rcCompactHeightfield chf, long borderSize, long minRegionArea, long mergeRegionArea);

    boolean buildLayerRegions(rcContext ctx, [Ref] rcCompactHeightfield chf, [Const] long borderSize, [Const] long minRegionArea);

    boolean buildRegionsMonotone(rcContext ctx, [Ref] rcCompactHeightfield chf, [Const] long borderSize, [Const] long minRegionArea, [Const] long mergeRegionArea);

    void setCon([Ref] rcCompactSpan s, long dir, long i);

    long getCon([Const, Ref] rcCompactSpan s, long dir);

    long getDirOffsetX(long dir);

    long getDirOffsetY(long dir);

    long getDirForOffset(long x, long y);

    boolean buildHeightfieldLayers(rcContext ctx, [Ref] rcCompactHeightfield chf, long borderSize, long walkableHeight, [Ref] rcHeightfieldLayerSet lset);

    boolean buildContours(rcContext ctx, [Ref] rcCompactHeightfield chf, [Const] float maxError, long maxEdgeLen, [Ref] rcContourSet cset, long buildFlags);

    boolean buildPolyMesh(rcContext ctx, [Ref] rcContourSet cset, long nvp, [Ref] rcPolyMesh mesh);

    boolean mergePolyMeshes(rcContext ctx, rcPolyMesh[] meshes, long nmeshes, [Ref] rcPolyMesh mesh);

    boolean buildPolyMeshDetail(rcContext ctx, [Ref] rcPolyMesh mesh, [Ref] rcCompactHeightfield chf, [Const] float sampleDist, [Const] float sampleMaxError, [Ref] rcPolyMeshDetail dmesh);

    boolean copyPolyMesh(rcContext ctx, [Const, Ref] rcPolyMesh src, [Ref] rcPolyMesh dst);

    boolean mergePolyMeshDetails(rcContext ctx, rcPolyMeshDetail[] meshes, [Const] long nmeshes, [Ref] rcPolyMeshDetail dmesh);

    UnsignedCharArray getHeightfieldLayerHeights(rcHeightfieldLayer heightfieldLayer);

    UnsignedCharArray getHeightfieldLayerAreas(rcHeightfieldLayer heightfieldLayer);

    UnsignedCharArray getHeightfieldLayerCons(rcHeightfieldLayer heightfieldLayer);

    rcHeightfield allocHeightfield();
    void freeHeightfield(rcHeightfield hf);

    rcCompactHeightfield allocCompactHeightfield();
    void freeCompactHeightfield(rcCompactHeightfield chf);

    rcHeightfieldLayerSet allocHeightfieldLayerSet();
    void freeHeightfieldLayerSet(rcHeightfieldLayerSet lset);

    rcContourSet allocContourSet();
    void freeContourSet(rcContourSet cset);

    rcPolyMesh allocPolyMesh();
    void freePolyMesh(rcPolyMesh mesh);

    rcPolyMeshDetail allocPolyMeshDetail();
    void freePolyMeshDetail(rcPolyMeshDetail dmesh);
};

interface CreateNavMeshDataResult {
    attribute boolean success;
    attribute UnsignedCharArray navMeshData;
};

interface DetourNavMeshBuilder {
    void DetourNavMeshBuilder();

    void setPolyMeshCreateParams(dtNavMeshCreateParams navMeshCreateParams, rcPolyMesh polyMesh);

    void setPolyMeshDetailCreateParams(dtNavMeshCreateParams navMeshCreateParams, rcPolyMeshDetail polyMeshDetail);

    void setOffMeshConnections(dtNavMeshCreateParams navMeshCreateParams, long offMeshConCount, float[] offMeshConVerts, float[] offMeshConRad, octet[] offMeshConDirs, octet[] offMeshConAreas, unsigned short[] offMeshConFlags, unsigned long[] offMeshConUserId);

    CreateNavMeshDataResult createNavMeshData([Ref] dtNavMeshCreateParams params);
};

interface dtTileCacheLayer {
};

interface dtTileCacheContourSet {
};

interface dtTileCachePolyMesh {
};

interface dtTileCacheLayerHeader {
    void dtTileCacheLayerHeader();

    attribute long magic;
    attribute long version;
    attribute long tx;
    attribute long ty;
    attribute long tlayer;
    attribute float[] bmin;
    attribute float[] bmax;
    attribute short hmin;
    attribute short hmax;
    attribute octet width;
    attribute octet height;
    attribute octet minx;
    attribute octet maxx;
    attribute octet miny;
    attribute octet maxy;
};

interface DetourTileCacheBuilder {
    void DetourTileCacheBuilder();

    long buildTileCacheLayer(RecastFastLZCompressor comp, dtTileCacheLayerHeader header, [Const] UnsignedCharArray heights, [Const] UnsignedCharArray areas, [Const] UnsignedCharArray cons, UnsignedCharArray tileCacheData);
};

interface rcChunkyTriMeshNode {
    attribute float[] bmin;
    attribute float[] bmax;
    attribute long i;
    attribute long n;
};

interface rcChunkyTriMesh {
    void rcChunkyTriMesh();

    [Value] attribute rcChunkyTriMeshNode[] nodes;
    attribute long nnodes;
    attribute long[] tris;
    attribute long ntris;
    attribute long maxTrisPerChunk;
};

interface ChunkyTriMeshUtils {
    void ChunkyTriMeshUtils();

    boolean createChunkyTriMesh([Const] FloatArray verts, [Const] IntArray tris, long ntris, long trisPerChunk, rcChunkyTriMesh chunkyTriMesh);

    long getChunksOverlappingRect(rcChunkyTriMesh chunkyTriMesh, float[] bmin, float[] bmax, IntArray ids, [Const] long maxIds);

    IntArray getChunkyTriMeshNodeTris(rcChunkyTriMesh chunkyTriMesh, long nodeIndex);
};

interface BoolRef {
    void BoolRef();

    attribute boolean value;
};

interface IntRef {
    void IntRef();

    attribute long value;
};

interface UnsignedIntRef {
    void UnsignedIntRef();

    attribute unsigned long value;
};

interface UnsignedCharRef {
    void UnsignedCharRef();

    attribute octet value;
};

interface UnsignedShortRef {
    void UnsignedShortRef();

    attribute unsigned long value;
};

interface FloatRef {
    void FloatRef();

    attribute float value;
};


interface IntArray {
    void IntArray();

    attribute long[] data;
    attribute long size;
    attribute boolean isView;

    void resize(long size);
    void copy([Const] long[] data, long size);
    void free();

    long get(long i);
    void set(long i, long value);

    any getDataPointer();
};

interface UnsignedIntArray {
    void UnsignedIntArray();

    attribute unsigned long[] data;
    attribute long size;
    attribute boolean isView;

    void resize(long size);
    void copy([Const] unsigned long[] data, long size);
    void free();

    unsigned long get(long i);
    void set(long i, unsigned long value);

    any getDataPointer();
};

interface UnsignedCharArray {
    void UnsignedCharArray();

    attribute octet[] data;
    attribute long size;
    attribute boolean isView;

    void resize(long size);
    void copy([Const] octet[] data, long size);
    void free();

    octet get(long i);
    void set(long i, octet value);

    any getDataPointer();
};

interface UnsignedShortArray {
    void UnsignedShortArray();

    attribute unsigned short[] data;
    attribute long size;
    attribute boolean isView;

    void resize(long size);
    void copy([Const] unsigned short[] data, long size);
    void free();

    unsigned short get(long i);
    void set(long i, unsigned short value);

    any getDataPointer();
};

interface FloatArray {
    void FloatArray();

    attribute float[] data;
    attribute long size;
    attribute boolean isView;

    void resize(long size);
    void copy([Const] float[] data, long size);
    void free();

    float get(long i);
    void set(long i, float value);

    any getDataPointer();
};

interface NavMeshImporterResult {
    attribute NavMesh navMesh;
    attribute TileCache tileCache;
    attribute RecastLinearAllocator allocator;
    attribute RecastFastLZCompressor compressor;
};

interface NavMeshImporter {
    void NavMeshImporter();

    [Value] NavMeshImporterResult importNavMesh(NavMeshExport data, [Ref] TileCacheMeshProcessJsImpl meshProcess);
};

interface NavMeshExport {
    attribute any dataPointer;
    attribute long size;

    void NavMeshExport();
};

interface NavMeshExporter {
    void NavMeshExporter();

    [Value] NavMeshExport exportNavMesh(NavMesh navMesh, TileCache tileCache);
    void freeNavMeshExport(NavMeshExport navMeshExport);
};

enum duDebugDrawPrimitives {
    "duDebugDrawPrimitives::DU_DRAW_POINTS",
    "duDebugDrawPrimitives::DU_DRAW_LINES",
    "duDebugDrawPrimitives::DU_DRAW_TRIS",
    "duDebugDrawPrimitives::DU_DRAW_QUADS"
};

interface duDebugDraw {
};

interface DebugDraw {
};
DebugDraw implements duDebugDraw;

[JSImplementation="DebugDraw"]
interface DebugDrawImpl {
    void DebugDrawImpl();

    void handleDepthMask(boolean state);
    void handleTexture(boolean state);
    void handleBegin([Const] duDebugDrawPrimitives prim, float size);
    void handleVertexWithColor([Const] float x, [Const] float y, [Const] float z, [Const] unsigned long color);
    void handleVertexWithColorAndUV([Const] float x, [Const] float y, [Const] float z, [Const] unsigned long color, [Const] float u, [Const] float v);
    void handleEnd();
};

interface RecastDebugDraw {
    void RecastDebugDraw();

    void debugDrawHeightfieldSolid(duDebugDraw dd, [Const, Ref] rcHeightfield hf);
    void debugDrawHeightfieldWalkable(duDebugDraw dd, [Const, Ref] rcHeightfield hf);

    void debugDrawCompactHeightfieldSolid(duDebugDraw dd, [Const, Ref] rcCompactHeightfield chf);
    void debugDrawCompactHeightfieldRegions(duDebugDraw dd, [Const, Ref] rcCompactHeightfield chf);
    void debugDrawCompactHeightfieldDistance(duDebugDraw dd, [Const, Ref] rcCompactHeightfield chf);

    void debugDrawHeightfieldLayer(duDebugDraw dd, [Const, Ref] rcHeightfieldLayer layer, long idx);
    void debugDrawHeightfieldLayers(duDebugDraw dd, [Const, Ref] rcHeightfieldLayerSet lset);

    void debugDrawRegionConnections(duDebugDraw dd, [Const, Ref] rcContourSet cset, float alpha);
    void debugDrawRawContours(duDebugDraw dd, [Const, Ref] rcContourSet cset, float alpha);
    void debugDrawContours(duDebugDraw dd, [Const, Ref] rcContourSet cset, float alpha);

    void debugDrawPolyMesh(duDebugDraw dd, [Const, Ref] rcPolyMesh mesh);
    void debugDrawPolyMeshDetail(duDebugDraw dd, [Const, Ref] rcPolyMeshDetail dmesh);
};

interface DetourDebugDraw {
    void DetourDebugDraw();

    void debugDrawNavMesh(duDebugDraw dd, [Const, Ref] dtNavMesh mesh, [Const] unsigned long flags);
    void debugDrawNavMeshWithClosedList(duDebugDraw dd, [Const, Ref] dtNavMesh mesh, [Const, Ref] dtNavMeshQuery query, [Const] unsigned long flags);
    void debugDrawNavMeshNodes(duDebugDraw dd, [Const, Ref] dtNavMeshQuery query);
    void debugDrawNavMeshBVTree(duDebugDraw dd, [Const, Ref] dtNavMesh mesh);
    void debugDrawNavMeshPortals(duDebugDraw dd, [Const, Ref] dtNavMesh mesh);
    void debugDrawNavMeshPolysWithFlags(duDebugDraw dd, [Const, Ref] dtNavMesh mesh, [Const] unsigned short flags, [Const] unsigned long col);
    void debugDrawNavMeshPoly(duDebugDraw dd, [Const, Ref] dtNavMesh mesh, unsigned long ref, unsigned long col);

    void debugDrawTileCacheLayerAreas(duDebugDraw dd, [Const, Ref] dtTileCacheLayer layer, [Const] float cs, [Const] float ch);
    void debugDrawTileCacheLayerRegions(duDebugDraw dd, [Const, Ref] dtTileCacheLayer layer, [Const] float cs, [Const] float ch);
    void debugDrawTileCacheContours(duDebugDraw dd, [Const, Ref] dtTileCacheContourSet lcset, [Const] float[] orig, [Const] float cs, [Const] float ch);
    void debugDrawTileCachePolyMesh(duDebugDraw dd, [Const, Ref] dtTileCachePolyMesh pmesh, [Const] float[] orig, [Const] float cs, [Const] float ch);
};
